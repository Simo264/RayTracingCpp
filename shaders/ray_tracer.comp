#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Ray 
{
  vec3 origin;
  vec3 direction;
};
struct Material 
{
  // Recommended: Use vec4 for better alignment and simplicity
  vec4 color_scale;
  vec4 emission_scale;
  float roughness_scale;
  int material_id; // 0:Matte 1:Metal
  vec2 _pad;
};
struct Sphere 
{
  vec3 center;
  float radius;
  Material material;
};
struct Plane 
{
  // Recommended: Use vec4 for better alignment and simplicity
  vec4 position;
  vec4 normal;
  vec2 size;
  vec2 __pad;
  Material material;
};
struct HitRecord 
{
  vec3 point;
  vec3 normal;
  bool front_face;
  float t;
  float tc_u; 
  float tc_v;
  Material material;
};


// Binding 0: Output Image
layout(binding = 0, rgba8) restrict uniform writeonly image2D outputImage;

// Binding 1: Camera
//layout(binding = 1, std430) restrict readonly buffer CameraBuffer { GpuCamera camera; };

layout(binding = 2, std430) restrict readonly buffer SphereBuffer { Sphere spheres[]; };

layout(binding = 3, std430) restrict readonly buffer PlaneBuffer { Plane plane; };

layout(binding = 4, std430) restrict readonly buffer LightBuffer { Sphere light; };


uint hash(uint x);
float random_float(inout uint seed);
vec3 random_in_unit_sphere(inout uint seed);
bool scatterMatte(const Ray incident, 
                  const HitRecord hit, 
                  inout vec3 surface_color, 
                  inout Ray scattered_ray, 
                  inout uint random_seed);

bool scatterMetal(const Ray incident,
                   const HitRecord hit,
                   inout vec3 surface_color,
                   inout Ray scattered_ray,
                   inout uint random_seed);

bool intersectSphere(Ray ray, Sphere sphere, out HitRecord hit, float t_min, float t_max);
vec2 getPlaneTextureCoordinates(vec3 hit_point, Plane plane);
bool intersectPlane(Ray ray, Plane plane, out HitRecord hit, float t_min, float t_max);
vec3 getSkyColor(vec3 direction);
Ray generateRay(ivec2 pixel, ivec2 image_size, vec3 position);

const float INFINITY = 1000000.f;
const int MAX_BOUNCES = 16;
uint random_seed;

void main() 
{
  ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
  ivec2 image_size = imageSize(outputImage);
  if (pixel.x >= image_size.x || pixel.y >= image_size.y)
      return;

  Ray ray = generateRay(pixel, image_size, vec3(0.0, 0.0, 2.0));

  // Inizializza il seme casuale. Usiamo un hash dell'ID del pixel
  // per garantire che ogni thread abbia un seme diverso.
  random_seed = uint(pixel.x) * 192837u + uint(pixel.y) * 456789u;

  vec3 final_color = vec3(0.0);
  vec3 throughput = vec3(1.0); // Renamed "attenuation" to "throughput" for clarity
  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) 
  {
    HitRecord closest_hit;
    closest_hit.t = INFINITY;
    bool hit_found = false;

    float t_min = 1e-3f;

    // Intersezione con sfere
    for (int j = 0; j < spheres.length(); ++j) 
    {
      HitRecord current_hit;
      if (intersectSphere(ray, spheres[j], current_hit, t_min, closest_hit.t)) 
      {
        closest_hit = current_hit;
        hit_found = true;
      }
    }

    // Intersezione con piano
    {
      HitRecord current_hit;
      if (intersectPlane(ray, plane, current_hit, t_min, closest_hit.t)) 
      {
        closest_hit = current_hit;
        hit_found = true;
      }
    }

    // Intersezione con luce
    {
      HitRecord current_hit;
      if (intersectSphere(ray, light, current_hit, t_min, closest_hit.t)) 
      {
        closest_hit = current_hit;
        hit_found = true;
      }
    }

    if (!hit_found) 
    {
      final_color += throughput * getSkyColor(ray.direction);
      break;
    }

    // SE COLPISCO UNA LUCE, AGGIUNGO EMISSIVO E TERMINO
    if (closest_hit.material.material_id == 2) 
    {
      final_color += closest_hit.material.emission_scale.rgb;
      break;
    }

    // ----------------------------------------------------------
    // ILLUMINAZIONE DIRETTA (Light Sampling)
    // ----------------------------------------------------------
    vec3 direct_light_contribution = vec3(0.0);
    vec3 to_light = light.center - closest_hit.point;
    float light_dist = length(to_light);
    vec3 to_light_direction = normalize(to_light);

    Ray shadow_ray;
    shadow_ray.origin = closest_hit.point + closest_hit.normal * 1e-4f;
    shadow_ray.direction = to_light_direction;

    bool is_in_shadow = false;
    HitRecord temp_hit;

    // Test contro sfere (NON la luce, perché non è in spheres[])
    for (int j = 0; j < spheres.length(); ++j) 
    {
      if (intersectSphere(shadow_ray, spheres[j], temp_hit, 1e-4f, light_dist - 1e-4f)) 
      {
        is_in_shadow = true;
        break;
      }
    }

    // Test contro piano
    if (!is_in_shadow) 
    {
      if (intersectPlane(shadow_ray, plane, temp_hit, 1e-4f, light_dist - 1e-4f))
        is_in_shadow = true;
    }

    if (!is_in_shadow) 
    {
      float cosine_term = max(dot(closest_hit.normal, to_light_direction), 0.0);
      vec3 light_color = light.material.emission_scale.rgb;
      direct_light_contribution = closest_hit.material.color_scale.rgb * light_color * cosine_term / (light_dist * light_dist);
      final_color += throughput * direct_light_contribution;
    }

    // ----------------------------------------------------------
    // ILLUMINAZIONE INDIRETTA (BSDF Sampling)
    // ----------------------------------------------------------
    vec3 surface_color;
    Ray scattered_ray;
    bool scattered = false;
    if (closest_hit.material.material_id == 0) // Matte
        scattered = scatterMatte(ray, closest_hit, surface_color, scattered_ray, random_seed);
    else if (closest_hit.material.material_id == 1) // Metal
        scattered = scatterMetal(ray, closest_hit, surface_color, scattered_ray, random_seed);

    if (!scattered)
        break;

    ray = scattered_ray;
    throughput *= surface_color;
}
    
  // Scrivi il colore finale nell'immagine
  // (Nota: per il "Path Tracing", solitamente si normalizza il colore finale
  // dividendo per il numero di campioni per pixel, ma qui gestiamo un solo raggio per pixel)
  imageStore(outputImage, pixel, vec4(final_color, 1.0));
}

uint hash(uint x) 
{
  x = (x ^ (x >> 16)) * 0x85ebca6b;
  x = (x ^ (x >> 13)) * 0xc2b2ae35;
  x = (x ^ (x >> 16));
  return x;
}
float random_float(inout uint seed) 
{
  seed = hash(seed);
  return float(seed) / float(0xffffffffu);
}
vec3 random_in_unit_sphere(inout uint seed) 
{
  float z = random_float(seed) * 2.0 - 1.0;
  float r = sqrt(max(0.0, 1.0 - z*z)); // evita sqrt negativo (safety)
  float phi = random_float(seed) * 2.0 * 3.14159265359;
  float x = r * cos(phi);
  float y = r * sin(phi);
  float scale = pow(random_float(seed), 1.0/3.0);
  return vec3(x, y, z) * scale;
}

bool scatterMatte(const Ray incident, 
                  const HitRecord hit, 
                  inout vec3 surface_color, 
                  inout Ray scattered_ray, 
                  inout uint random_seed) 
{
  vec3 random_dir = random_in_unit_sphere(random_seed);
  vec3 scatter_dir = hit.normal + normalize(random_dir);
  
  // Gestisce il caso di scattering verso l'interno (vicino a zero)
  if (length(scatter_dir) < 1e-6) 
    scatter_dir = hit.normal;
  
  scattered_ray.origin = hit.point;
  scattered_ray.direction = normalize(scatter_dir);
  
  surface_color = hit.material.color_scale.rgb;
  return true;
}


bool scatterMetal(const Ray incident,
                   const HitRecord hit,
                   inout vec3 surface_color,
                   inout Ray scattered_ray,
                   inout uint random_seed) 
{
  vec3 reflected_dir = reflect(normalize(incident.direction), hit.normal);
  vec3 random_in_sphere = random_in_unit_sphere(random_seed);
  vec3 scattered_dir = reflected_dir + (hit.material.roughness_scale * random_in_sphere);
  scattered_ray.origin = hit.point;
  scattered_ray.direction = normalize(scattered_dir);
  surface_color = hit.material.color_scale.rgb;
  return (dot(scattered_ray.direction, hit.normal) > 0.0);
}

bool intersectSphere(Ray ray, Sphere sphere, out HitRecord hit, float t_min, float t_max) 
{
  vec3 oc = ray.origin - sphere.center;
  float a = dot(ray.direction, ray.direction); // Sempre 1 se normalizzato
  float b = 2.0 * dot(oc, ray.direction);
  float c = dot(oc, oc) - sphere.radius * sphere.radius;
  float discriminant = b * b - 4.0 * a * c;

  if (discriminant < 1e-6) 
    return false;

  float sqrt_disc = sqrt(discriminant);
  float denom = 2.0 * a;
  float t = (-b - sqrt_disc) / denom;
  if (t < t_min || t > t_max) 
  { 
    t = (-b + sqrt_disc) / denom;
    if (t < t_min || t > t_max) 
        return false;
  }

  hit.t = t;
  hit.point = ray.origin + t * ray.direction;
  hit.normal = normalize(hit.point - sphere.center);
  hit.material = sphere.material;
  hit.front_face = dot(ray.direction, hit.normal) < 0.0;
  if (!hit.front_face)
      hit.normal = -hit.normal;

  return true;
}
vec2 getPlaneTextureCoordinates(vec3 hit_point, Plane plane) 
{
  vec3 u_vec;
  if (abs(plane.normal.y) < 0.9) 
    u_vec = normalize(cross(plane.normal.xyz, vec3(0, 1, 0)));
  else 
    u_vec = normalize(cross(plane.normal.xyz, vec3(1, 0, 0)));
  
  vec3 v_vec = cross(plane.normal.xyz, u_vec);
    
  // Proietta il punto di hit sul piano locale.
  vec3 relative_hit_point = hit_point - plane.position.xyz;
  float u = dot(relative_hit_point, u_vec);
  float v = dot(relative_hit_point, v_vec);
  return vec2(u, v);
}
bool intersectPlane(Ray ray, Plane plane, out HitRecord hit, float t_min, float t_max) 
{
  vec3 p0 = plane.position.xyz;
  vec3 n = plane.normal.xyz;
  vec3 r0 = ray.origin;
  vec3 d = ray.direction;
  float denom = dot(d, n);
  // Evita la divisione per zero se il raggio è parallelo al piano
  if (abs(denom) < 1e-6) 
    return false;

  float t = dot(p0 - r0, n) / denom;
  if (t < t_min || t > t_max) 
      return false;

  vec3 hit_point = r0 + t * d;
  vec2 local_coords = getPlaneTextureCoordinates(hit_point, plane);

  // Controlla se il punto di intersezione è all'interno della dimensione del piano
  if (abs(local_coords.x) > (plane.size.x / 2.0) || abs(local_coords.y) > (plane.size.y / 2.0)) 
      return false;

  // Normalizza le coordinate UV nel range [0, 1]
  hit.tc_u = (local_coords.x / plane.size.x) + 0.5;
  hit.tc_v = (local_coords.y / plane.size.y) + 0.5;
  hit.t = t;
  hit.point = hit_point;
  hit.front_face = true;
  hit.normal = n;
  hit.material = plane.material;
  if (dot(ray.direction, n) > 0.0) 
  {
    hit.front_face = false;
    hit.normal = -n;
  } 
  return true;
}

Ray generateRay(ivec2 pixel, ivec2 image_size, vec3 origin)
{
  vec2 uv = vec2(pixel) / vec2(image_size);
  uv = uv * 2.0 - 1.0;
  uv.y *= -1.0; 
  uv.x *= float(image_size.x) / float(image_size.y);
  Ray ray;
  ray.origin = origin;
  ray.direction = normalize(vec3(uv, -1.0));  // Guarda verso -Z
  return ray;
}

vec3 getSkyColor(vec3 direction)
{
    vec3 unit_direction = normalize(direction);
    float a = 0.5 * (unit_direction.y + 1.0);
    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), a);
}



