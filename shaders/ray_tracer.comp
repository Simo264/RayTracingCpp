#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Ray 
{
  vec3 origin;
  vec3 direction;
};
struct Material 
{
  // Recommended: Use vec4 for better alignment and simplicity
  vec4 color_scale;
  vec4 emission_scale;
  float roughness_scale;
};
struct Sphere 
{
  vec3 center;
  float radius;
  Material material;
};
struct Plane 
{
  // Recommended: Use vec4 for better alignment and simplicity
  vec4 position;
  vec4 normal;
  vec2 size;
  vec2 __padding;
  Material material;
};
struct HitRecord 
{
  vec3 point;
  vec3 normal;
  bool front_face;
  float t;
  float tc_u; 
  float tc_v;
  Material material;
};


// Binding 0: Output Image
layout(binding = 0, rgba8) restrict uniform writeonly image2D outputImage;

// Binding 1: Camera
//layout(binding = 1, std430) restrict readonly buffer CameraBuffer {
//  GpuCamera camera;
//};

// Binding 2: Sphere SSBO
layout(binding = 2, std430) restrict readonly buffer SphereBuffer {
  Sphere spheres[];
};

// Binding 3: Plane SSBO
layout(binding = 3, std430) restrict readonly buffer PlaneBuffer {
  Plane plane;
};

bool intersectSphere(Ray ray, Sphere sphere, out HitRecord hit, float t_min, float t_max);

vec2 getPlaneTextureCoordinates(vec3 hit_point, Plane plane);
bool intersectPlane(Ray ray, Plane plane, out HitRecord hit, float t_min, float t_max);

const float INFINITY = 1000000.f;

void main() 
{
  ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
  ivec2 imageSize = imageSize(outputImage);

  if (pixel.x >= imageSize.x || pixel.y >= imageSize.y)
      return;

  vec2 uv = vec2(pixel) / vec2(imageSize);
  uv = uv * 2.0 - 1.0;
  uv.y *= -1.0; // Aggiungi questa riga
  uv.x *= float(imageSize.x) / float(imageSize.y);

  Ray ray;
  ray.origin = vec3(0.0, 0.0, 2.0);           // Camera leggermente davanti
  ray.direction = normalize(vec3(uv, -1.0));  // Guarda verso -Z

  HitRecord closest_hit;
  closest_hit.t = INFINITY;
  bool hit_found = false;


  // 1. Interseca il raggio con le sfere
  for(int i = 0; i < spheres.length(); ++i) 
  {
    HitRecord current_hit;
    if (intersectSphere(ray, spheres[i], current_hit, 0.001, closest_hit.t))
    {
      closest_hit = current_hit;
      hit_found = true;
    }
  }

  // 2. Interseca il raggio con il piano
  {
    HitRecord current_hit;
    if (intersectPlane(ray, plane, current_hit, 0.001, closest_hit.t)) 
    {
      closest_hit = current_hit;
      hit_found = true;
    }
  }
  
  
  vec4 color;
  if (hit_found) 
  {
    // Usa solo il colore RGB del materiale (ignora alpha per ora)
    color = vec4(closest_hit.material.color_scale.rgb, 1.0);
    //color = vec4(1.0, 0.0, 0.0, 1.0);
  }
  else
  {
    vec3 unit_direction = normalize(ray.direction);
    float a = (unit_direction.y + 1.0) * 0.5;
    vec3 sky_color = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), a);
    color = vec4(sky_color, 1.0); // Sfondo: gradiente cielo
  }

  imageStore(outputImage, pixel, color);
}

bool intersectSphere(Ray ray, Sphere sphere, out HitRecord hit, float t_min, float t_max) 
{
  vec3 oc = ray.origin - sphere.center;
  float a = dot(ray.direction, ray.direction); // Sempre 1 se normalizzato
  float b = 2.0 * dot(oc, ray.direction);
  float c = dot(oc, oc) - sphere.radius * sphere.radius;
  float discriminant = b * b - 4.0 * a * c;

  if (discriminant < 1e-6) 
    return false;

  float sqrt_disc = sqrt(discriminant);
  float denom = 2.0 * a;
  float t = (-b - sqrt_disc) / denom;
  if (t < t_min || t > t_max) 
  { 
    t = (-b + sqrt_disc) / denom;
    if (t < t_min || t > t_max) 
        return false;
  }

  hit.t = t;
  hit.point = ray.origin + t * ray.direction;
  hit.normal = normalize(hit.point - sphere.center);
  hit.material = sphere.material;
  hit.front_face = dot(ray.direction, hit.normal) < 0.0;
  if (!hit.front_face)
      hit.normal = -hit.normal;

  return true;
}


vec2 getPlaneTextureCoordinates(vec3 hit_point, Plane plane) 
{
  vec3 u_vec;
  if (abs(plane.normal.y) < 0.9) 
    u_vec = normalize(cross(plane.normal.xyz, vec3(0, 1, 0)));
  else 
    u_vec = normalize(cross(plane.normal.xyz, vec3(1, 0, 0)));
  
  vec3 v_vec = cross(plane.normal.xyz, u_vec);
    
  // Proietta il punto di hit sul piano locale.
  vec3 relative_hit_point = hit_point - plane.position.xyz;
  float u = dot(relative_hit_point, u_vec);
  float v = dot(relative_hit_point, v_vec);
  return vec2(u, v);
}

bool intersectPlane(Ray ray, Plane plane, out HitRecord hit, float t_min, float t_max) 
{
  vec3 p0 = plane.position.xyz;
  vec3 n = plane.normal.xyz;
  vec3 r0 = ray.origin;
  vec3 d = ray.direction;
  float denom = dot(d, n);
  // Evita la divisione per zero se il raggio è parallelo al piano
  if (abs(denom) < 1e-6) 
    return false;

  float t = dot(p0 - r0, n) / denom;
  if (t < t_min || t > t_max) 
      return false;

  vec3 hit_point = r0 + t * d;
  vec2 local_coords = getPlaneTextureCoordinates(hit_point, plane);

  // Controlla se il punto di intersezione è all'interno della dimensione del piano
  if (abs(local_coords.x) > (plane.size.x / 2.0) || abs(local_coords.y) > (plane.size.y / 2.0)) 
      return false;

  // Normalizza le coordinate UV nel range [0, 1]
  hit.tc_u = (local_coords.x / plane.size.x) + 0.5;
  hit.tc_v = (local_coords.y / plane.size.y) + 0.5;
  hit.t = t;
  hit.point = hit_point;
  hit.front_face = true;
  hit.normal = n;
  hit.material = plane.material;
  if (dot(ray.direction, n) > 0.0) 
  {
    hit.front_face = false;
    hit.normal = -n;
  } 
  return true;
}


